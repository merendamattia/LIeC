<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
		<title>02-analisi-lessicale</title>
		<style>
			/*
github.com style (c) Vasily Polovnyov <vast@whiteants.net>
*/
  
  .hljs-comment,
  .hljs-quote {
    color: #998;
    font-style: italic;
  }
  
  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-subst {
    color: #333;
    font-weight: bold;
  }
  
  .hljs-number,
  .hljs-literal,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-tag .hljs-attr {
    color: #008080;
  }
  
  .hljs-string,
  .hljs-doctag {
    color: #d14;
  }
  
  .hljs-title,
  .hljs-section,
  .hljs-selector-id {
    color: #900;
    font-weight: bold;
  }
  
  .hljs-subst {
    font-weight: normal;
  }
  
  .hljs-type,
  .hljs-class .hljs-title {
    color: #458;
    font-weight: bold;
  }
  
  .hljs-tag,
  .hljs-name,
  .hljs-attribute {
    color: #000080;
    font-weight: normal;
  }
  
  .hljs-regexp,
  .hljs-link {
    color: #009926;
  }
  
  .hljs-symbol,
  .hljs-bullet {
    color: #990073;
  }
  
  .hljs-built_in,
  .hljs-builtin-name {
    color: #0086b3;
  }
  
  .hljs-meta {
    color: #999;
    font-weight: bold;
  }
  
  .hljs-deletion {
    background: #fdd;
  }
  
  .hljs-addition {
    background: #dfd;
  }
  
  .hljs-emphasis {
    font-style: italic;
  }
  
  .hljs-strong {
    font-weight: bold;
  }
		</style>
	</head>
	<body>
		<nav id="table-of-contents">
			<ul><li><a href="#richiami-di-nozioni-base-dei-linguaggi-formali"> Richiami di nozioni base dei linguaggi formali</a><ul><li><a href="#sintassi-delle-espressioni-regolari"> Sintassi delle espressioni regolari</a></li><li><a href="#semantica-delle-espressioni-regolari"> Semantica delle espressioni regolari</a></li></ul></li><li><a href="#classificazione-dei-token-dei-linguaggi-di-programmazione"> Classificazione dei token dei linguaggi di programmazione</a><ul><li><a href="#risoluzione-ambiguit%C3%A0"> Risoluzione ambiguità</a></li></ul></li></ul>
		</nav>
		<main>
			<pre><code class="language-table-of-contents"></code></pre>
<hr>
<h1 id="richiami-di-nozioni-base-dei-linguaggi-formali" tabindex="-1"><a class="anchor" href="#richiami-di-nozioni-base-dei-linguaggi-formali" aria-hidden="true"><span class="octicon octicon-link"></span></a> Richiami di nozioni base dei linguaggi formali</h1>
<p>![[02-01.png]]</p>
<h2 id="sintassi-delle-espressioni-regolari" tabindex="-1"><a class="anchor" href="#sintassi-delle-espressioni-regolari" aria-hidden="true"><span class="octicon octicon-link"></span></a> Sintassi delle espressioni regolari</h2>
<p>![[02-02.png]]
![[02-04.png]]</p>
<h2 id="semantica-delle-espressioni-regolari" tabindex="-1"><a class="anchor" href="#semantica-delle-espressioni-regolari" aria-hidden="true"><span class="octicon octicon-link"></span></a> Semantica delle espressioni regolari</h2>
<p>![[02-03.png]]</p>
<blockquote>
<p>Manca l'insieme vuoto.</p>
</blockquote>
<p>![[02-05.png]]</p>
<hr>
<h1 id="classificazione-dei-token-dei-linguaggi-di-programmazione" tabindex="-1"><a class="anchor" href="#classificazione-dei-token-dei-linguaggi-di-programmazione" aria-hidden="true"><span class="octicon octicon-link"></span></a> Classificazione dei token dei linguaggi di programmazione</h1>
<ul>
<li>Parole chiave (keyword)
<ul>
<li><code>if, then, else, while, ...</code></li>
<li>Si usa l’alternanza: <code>if | then | else | while ...</code></li>
<li>Unica categoria sintattica: KEYWORD</li>
<li>Case insensitive (e.g., SQL)
<ul>
<li><code>select, SELECT, SeLeCt, SELect, ...</code></li>
<li>Noioso e troppo verboso: si usano impostazioni ad hoc</li>
</ul>
</li>
</ul>
</li>
<li>Identificatori
<ul>
<li><code>[a-zA-Z_][0-9a-zA-Z_]*</code></li>
<li><code>[a-zA-Z_]([0-9] | [a-zA-Z_])*</code></li>
<li><code>DIGIT = [0-9] </code></li>
<li><code>LETTER = [a-zA-Z_]</code></li>
<li><code>{LETTER}({DIGIT}|{LETTER})*</code></li>
</ul>
</li>
<li>Costanti letterali (intere, floating point, stringa, ecc.)
<ul>
<li>Costanti intere
<ul>
<li><code>{DIGIT}+</code></li>
<li>Nota: accetta <code>000000</code>, non accetta <code>-1</code></li>
</ul>
</li>
<li>Costanti floating point
<ul>
<li><code>[+-]?[0-9]+.[0-9]*</code></li>
<li>occorre distinguere iterazione positiva dal carattere <code>+</code> ?</li>
</ul>
</li>
<li>Costanti carattere
<ul>
<li><code>’[^’]’</code></li>
<li>come specifichiamo la costante carattere <code>’</code> ?</li>
</ul>
</li>
</ul>
</li>
<li>Operatori (matematici, logici, ecc.)</li>
<li>Punteggiatura (parentesi, virgola, punto e virgola, ecc.)
<ul>
<li>![[02-06.png]]</li>
</ul>
</li>
<li>Commenti (singola linea, multi linea)
<ul>
<li>Commento (singola linea) del C++
<ul>
<li><code>//[^\n]*\n</code></li>
</ul>
</li>
<li>Commento (singola linea) di SQL
<ul>
<li><code>--[^\n]*\n</code></li>
</ul>
</li>
<li>Commento multilinea (C / C++ / Java / SQL / ... )
<ul>
<li><code>/\*([^*]|\*+[^/*])*\*+/</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="risoluzione-ambiguit%C3%A0" tabindex="-1"><a class="anchor" href="#risoluzione-ambiguit%C3%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a> Risoluzione ambiguità</h2>
<p>Più RE possono accettare (parti de-) lo stesso input.
Viene data la preferenza al lessema più lungo</p>
<ul>
<li><code>forwhile</code> è un unico IDENT (non sono le due KEYWORD for e while)</li>
<li><code>&gt;&gt;</code> è un unico SHIFT RIGHT (non due GREATER THAN)</li>
</ul>
<p>A parità di lunghezza si stabilisce un ordine di priorità tra le RE.</p>
<p>A volte queste regole possono creare situazioni noiose:
Per lo standard C++03 e precedenti:</p>
<ul>
<li>corretto: <code>std::vector&lt;std::list&lt;int&gt; &gt;</code></li>
<li>errore (sintattico): <code>std::vector&lt;std::list&lt;int&gt;&gt;</code>
Per lo standard C++11 e successivi:</li>
<li>corretto: <code>std::vector&lt;std::list&lt;int&gt; &gt;</code></li>
<li>corretto: <code>std::vector&lt;std::list&lt;int&gt;&gt;</code></li>
</ul>

		</main>
	</body>
</html>
